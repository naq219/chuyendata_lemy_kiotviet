"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhookHandler = void 0;
const crypto_1 = require("crypto");
const webhook_1 = require("../types/webhook");
class WebhookHandler {
    constructor(client) {
        this.client = client;
    }
    /**
     * List webhooks with optional filtering
     * @param params Filter parameters
     */
    list() {
        return __awaiter(this, arguments, void 0, function* (params = {}) {
            const response = yield this.client.apiClient.get('/webhooks', { params });
            return response.data;
        });
    }
    /**
     * Get a webhook by its ID
     * @param webhookId The ID of the webhook to retrieve
     */
    getById(webhookId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.client.apiClient.get(`/webhooks/${webhookId}`);
            return response.data;
        });
    }
    /**
     * Create a new webhook
     * @param webhookData The webhook configuration data
     */
    create(webhookData) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.client.apiClient.post('/webhooks', webhookData);
            return response.data;
        });
    }
    /**
     * Update an existing webhook
     * @param webhookId The ID of the webhook to update
     * @param webhookData The webhook data to update
     */
    update(webhookId, webhookData) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.client.apiClient.put(`/webhooks/${webhookId}`, Object.assign({ id: webhookId }, webhookData));
            return response.data;
        });
    }
    /**
     * Delete a webhook
     * @param webhookId The ID of the webhook to delete
     */
    delete(webhookId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.apiClient.delete(`/webhooks/${webhookId}`);
        });
    }
    /**
     * Enable a webhook
     * @param webhookId The ID of the webhook to enable
     */
    enable(webhookId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.update(webhookId, { isActive: true });
        });
    }
    /**
     * Disable a webhook
     * @param webhookId The ID of the webhook to disable
     */
    disable(webhookId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.update(webhookId, { isActive: false });
        });
    }
    /**
     * Verify webhook signature
     * @param payload The raw webhook payload
     * @param signature The signature from X-KiotViet-Signature header
     * @param secret The webhook secret
     */
    verifySignature(payload, signature, secret) {
        const expectedSignature = (0, crypto_1.createHmac)('sha256', secret).update(payload).digest('hex');
        return signature === expectedSignature;
    }
    /**
     * Parse and verify webhook payload
     * @param payload The raw webhook payload string
     * @param signature The signature from X-Hub-Signature header
     * @param secret The webhook secret
     */
    parseWebhookPayload(payload, signature, secret) {
        if (!this.verifySignature(payload, signature, secret)) {
            throw new Error('Invalid webhook signature');
        }
        return JSON.parse(payload);
    }
    /**
     * Parse and verify a webhook payload with automatic type casting based on the event type
     * @param payload The raw webhook payload string
     * @param signature The signature from X-Hub-Signature header
     * @param secret The webhook secret
     */
    parseTypedWebhookPayload(payload, signature, secret, expectedEvent) {
        if (!this.verifySignature(payload, signature, secret)) {
            throw new Error('Invalid webhook signature');
        }
        const data = JSON.parse(payload);
        if (data.event !== expectedEvent) {
            throw new Error(`Expected ${expectedEvent} event but got ${data.event}`);
        }
        return data;
    }
    /**
     * Parse and verify customer update webhook payload
     * @param payload The raw webhook payload string
     * @param signature The signature from X-Hub-Signature header
     * @param secret The webhook secret
     */
    parseCustomerUpdateWebhook(payload, signature, secret) {
        return this.parseTypedWebhookPayload(payload, signature, secret, webhook_1.WebhookEvent.CustomerUpdated);
    }
    /**
     * Parse and verify product update webhook payload
     * @param payload The raw webhook payload string
     * @param signature The signature from X-Hub-Signature header
     * @param secret The webhook secret
     */
    parseProductUpdateWebhook(payload, signature, secret) {
        return this.parseTypedWebhookPayload(payload, signature, secret, webhook_1.WebhookEvent.ProductUpdated);
    }
    /**
     * Parse and verify order update webhook payload
     * @param payload The raw webhook payload string
     * @param signature The signature from X-Hub-Signature header
     * @param secret The webhook secret
     */
    parseOrderUpdateWebhook(payload, signature, secret) {
        return this.parseTypedWebhookPayload(payload, signature, secret, webhook_1.WebhookEvent.OrderUpdated);
    }
    /**
     * Parse and verify invoice update webhook payload
     * @param payload The raw webhook payload string
     * @param signature The signature from X-Hub-Signature header
     * @param secret The webhook secret
     */
    parseInvoiceUpdateWebhook(payload, signature, secret) {
        return this.parseTypedWebhookPayload(payload, signature, secret, webhook_1.WebhookEvent.InvoiceUpdated);
    }
    /**
     * Parse and verify stock update webhook payload
     * @param payload The raw webhook payload string
     * @param signature The signature from X-Hub-Signature header
     * @param secret The webhook secret
     */
    parseStockUpdateWebhook(payload, signature, secret) {
        return this.parseTypedWebhookPayload(payload, signature, secret, webhook_1.WebhookEvent.StockUpdated);
    }
    /**
     * Kiểm tra cấu trúc chung của webhook payload (trường hợp update)
     * @param payload Webhook payload dạng object (đã parse từ JSON)
     */
    validateGenericUpdatePayload(payload) {
        if (!payload || typeof payload !== 'object')
            return false;
        if (typeof payload.Id !== 'string')
            return false;
        if (typeof payload.Attempt !== 'number')
            return false;
        if (!Array.isArray(payload.Notifications))
            return false;
        return payload.Notifications.every((notification) => {
            if (!notification || typeof notification !== 'object')
                return false;
            if (typeof notification.Action !== 'string')
                return false;
            if (!Array.isArray(notification.Data))
                return false;
            return true;
        });
    }
    /**
     * Kiểm tra cấu trúc của payload xóa (RemoveId)
     * @param payload Webhook payload dạng object (đã parse từ JSON)
     */
    validateDeletePayload(payload) {
        if (!payload || typeof payload !== 'object')
            return false;
        if (!Array.isArray(payload.RemoveId))
            return false;
        return true;
    }
    /**
     * Kiểm tra xem webhook payload có hợp lệ không và có đúng cấu trúc cho customer.update không
     * @param payload Webhook payload dạng object (đã parse từ JSON)
     */
    validateCustomerUpdatePayload(payload) {
        if (!this.validateGenericUpdatePayload(payload))
            return false;
        // Kiểm tra cấu trúc riêng của customer
        return payload.Notifications.every((notification) => {
            return notification.Data.every((item) => {
                return typeof item.Id === 'number' && typeof item.Code === 'string' && typeof item.Name === 'string';
            });
        });
    }
    /**
     * Kiểm tra xem webhook payload có hợp lệ không và có đúng cấu trúc cho product.update không
     * @param payload Webhook payload dạng object (đã parse từ JSON)
     */
    validateProductUpdatePayload(payload) {
        if (!this.validateGenericUpdatePayload(payload))
            return false;
        // Kiểm tra cấu trúc riêng của product
        return payload.Notifications.every((notification) => {
            return notification.Data.every((item) => {
                return (typeof item.Id === 'number' &&
                    typeof item.Code === 'string' &&
                    typeof item.Name === 'string' &&
                    typeof item.CategoryId === 'number');
            });
        });
    }
    /**
     * Kiểm tra xem webhook payload có hợp lệ không và có đúng cấu trúc cho order.update không
     * @param payload Webhook payload dạng object (đã parse từ JSON)
     */
    validateOrderUpdatePayload(payload) {
        if (!this.validateGenericUpdatePayload(payload))
            return false;
        // Kiểm tra cấu trúc riêng của order
        return payload.Notifications.every((notification) => {
            return notification.Data.every((item) => {
                return (typeof item.Id === 'number' &&
                    typeof item.Code === 'string' &&
                    typeof item.PurchaseDate === 'string' &&
                    typeof item.BranchId === 'number' &&
                    Array.isArray(item.OrderDetails));
            });
        });
    }
}
exports.WebhookHandler = WebhookHandler;
