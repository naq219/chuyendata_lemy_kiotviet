"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenManager = void 0;
const axios_1 = __importDefault(require("axios"));
const errors_1 = require("../errors");
const constants_1 = require("../config/constants");
class TokenManager {
    constructor(config) {
        this.config = config;
        this._accessToken = null;
        this._tokenExpiresAt = null;
        this._isFetchingToken = false;
        this._tokenPromise = null;
    }
    getValidToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const now = Date.now();
            if (this._accessToken && this._tokenExpiresAt && this._tokenExpiresAt > now) {
                return this._accessToken;
            }
            return this.fetchNewToken();
        });
    }
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            this._accessToken = null;
            this._tokenExpiresAt = null;
            return this.fetchNewToken();
        });
    }
    fetchNewToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isFetchingToken && this._tokenPromise) {
                return this._tokenPromise;
            }
            this._isFetchingToken = true;
            this._tokenPromise = (() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                try {
                    const params = new URLSearchParams();
                    params.append('grant_type', 'client_credentials');
                    params.append('client_id', this.config.clientId);
                    params.append('client_secret', this.config.clientSecret);
                    params.append('scopes', constants_1.API_CONSTANTS.DEFAULT_SCOPE);
                    const response = yield axios_1.default.post(this.config.tokenUrl || constants_1.API_CONSTANTS.DEFAULT_TOKEN_URL, params, {
                        headers: { 'Content-Type': constants_1.CONTENT_TYPES.FORM_URLENCODED },
                    });
                    const { access_token, expires_in } = response.data;
                    this._accessToken = access_token;
                    this._tokenExpiresAt = Date.now() + (expires_in - constants_1.API_CONSTANTS.TOKEN_BUFFER_SECONDS) * 1000;
                    return access_token;
                }
                catch (error) {
                    this._accessToken = null;
                    this._tokenExpiresAt = null;
                    const responseData = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data;
                    const message = (responseData === null || responseData === void 0 ? void 0 : responseData.error_description) || (responseData === null || responseData === void 0 ? void 0 : responseData.error) || 'Failed to fetch access token';
                    throw new errors_1.AuthenticationError(message, responseData);
                }
                finally {
                    this._isFetchingToken = false;
                    this._tokenPromise = null;
                }
            }))();
            return this._tokenPromise;
        });
    }
}
exports.TokenManager = TokenManager;
